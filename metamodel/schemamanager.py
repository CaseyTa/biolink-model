"""
Datamodel for metamodel

See datamodel.py for pure (autogenerated) data access objects

This module provides an OO facade for accessing these
"""
import logging
from enum import Enum
from typing import Union, TextIO, List, Optional

from metamodel.metamodel import SchemaDefinition, SlotDefinition, ClassDefinition, TypeDefinition
from metamodel.utils.schemaloader import load_schema


class NameStyle(Enum):
    """
    Different systems have different name conventions.

    E.g. in most programming languages classes are CamelCase

    in some, property names are underscore separated.
    """
    CAMELCASE = 1
    UNDERSCORE = 2   ## aka snake-case
    NATURAL = 3
    LCAMELCASE = 4


class SchemaManager:
    """
    Facade object for working with schemas
    """
    def __init__(self) -> None:
        """
        """
        self.schema: SchemaDefinition = SchemaDefinition()
        self.loaded: List[str] = None
        self.unreferenced = set()

    def load_schema(self, data: Union[str, TextIO]):
        self.schema = load_schema(data)

    @staticmethod
    def get_name(n: str, style: NameStyle) -> str:
        if style == NameStyle.UNDERSCORE:
            return n.replace(" ","_").replace(",","")
        if style == NameStyle.CAMELCASE:
            # TODO: fix so microRNA -> MicroRNA
            return n.title().replace(" ","").replace(",","")
        if style == NameStyle.LCAMELCASE:
            s = n.title().replace(" ","").replace(",","")
            return s[0].lower() + s[1:]
        return n

    def predicates(self) -> List[SlotDefinition]:
        if not self.schema.slots:
            return []
        return [self.slotdef(s) for s in self.schema.slots]
    
    def root_predicates(self):
        """
        All slots/properties that lack a parent
        """
        return [p for p in self.predicates() if not p.is_a]
        
    def slotdef(self, sn: Union[str, SlotDefinition], c: Optional[ClassDefinition]=None) -> SlotDefinition:
        """
        lookup a slot in the schema by name

        Returns
        -------
        SlotDefinition
        """
        assert sn is not None
        if isinstance(sn, SlotDefinition):
            return sn
        if sn in self.schema.slots:
            return self.schema.slots[sn]

        # if not found, can use local definition
        if c and sn in c.slots:
            return self.schema.slots[sn]

        if sn not in self.unreferenced:
            logging.warning("No such slot: {} from class {}".format(sn, c))
            self.unreferenced.add(sn)

    @staticmethod
    def aliased_name(slot: SlotDefinition) -> str:
        return slot.alias if slot.alias else slot.name

    def slot_name(self, s: Union[str, SlotDefinition], style=NameStyle.UNDERSCORE):
        slot = self.slotdef(s)
        return self.get_name(self.aliased_name(slot), style)

    def type_name(self, t: Union[str, TypeDefinition], style=NameStyle.CAMELCASE):
        typ = self.typedef(t)
        if typ is None:
            raise ValueError("No type for {}".format(t))
        return self.get_name(t, style)

    def classdef(self, cn: Union[str, ClassDefinition]) -> ClassDefinition:
        """
        lookup a class in the schema by name

        Returns
        -------
        ClassDefinition
        """
        if isinstance(cn,ClassDefinition):
            return cn
        elif cn in self.schema.classes:
            return self.schema.classes[cn]
        elif cn not in self.unreferenced:
            logging.warning("No such class: {}".format(cn))
            self.unreferenced.add(cn)

    def typedef(self, tn: Union[str, TypeDefinition]) -> TypeDefinition:
        """
        lookup a type in the schema by name

        Returns
        -------
        TypeDefinition
        """
        if isinstance(tn,TypeDefinition):
            return tn
        elif tn in self.schema.types:
            return self.schema.types[tn]
        elif tn not in self.unreferenced:
            logging.warning("No such type: {}".format(tn))
            self.unreferenced.add(tn)


    def class_name(self, c: Union[str, ClassDefinition], style=NameStyle.CAMELCASE):
        cls = self.classdef(c)
        if cls is None:
            raise ValueError("No cls for {}".format(c))
        return self.get_name(cls.name, style)

    def obj_name(self, obj: Union[str, ClassDefinition, SlotDefinition, TypeDefinition]) -> str:
        if isinstance(obj, str):
            if obj in self.schema.classes:
                obj = self.schema.classes[obj]
            elif obj in self.schema.slots:
                obj = self.schema.slots[obj]
            elif obj in self.schema.types:
                obj = self.schema.types[obj]
            elif obj not in self.unreferenced:
                logging.warning("No such object: {}".format(obj))
                self.unreferenced.add(obj)
                return self.get_name(obj, style=NameStyle.CAMELCASE)
        if isinstance(obj, ClassDefinition):
            return self.class_name(obj)
        elif isinstance(obj, SlotDefinition):
            return self.slot_name(obj)
        else:
            return self.type_name(obj)
    
    def obj_uri(self, obj):
        return "http://bioentity.io/vocab/{}".format(self.obj_name(obj))

    def child_nodes(self, obj: Union[ClassDefinition, SlotDefinition], mixin=True) \
            -> List[Union[ClassDefinition, SlotDefinition]]:
        nodes = [c for c in self.schema.classes
                 if c.is_a is not None and c.is_a==obj.name and (not c.mixin or mixin)]
        nodes += [s for s in self.schema.slots
                  if s.is_a is not None and s.is_a==obj.name and (not s.mixin or mixin)]
        return nodes

    def child_nodes_by_mixin(self, obj: Union[ClassDefinition, SlotDefinition]) \
            -> List[Union[ClassDefinition, SlotDefinition]]:
        nodes = [c for c in self.schema.classes if obj.name in c.mixins]
        nodes += [s for s in self.schema.slots if obj.name in s.mixins]
        return nodes

    # returns pairs (cls, refCls) if cls references obj via refCls
    def all_class_usages(self, obj: str) -> List[Tuple[]]:
        pairs = []
        for c in self.schema.classes:
            rc =  self.get_class_usage_of(c, obj)
            if rc is not None:
                pairs.append((c, rc))
        return pairs

    # if a reference class rc directly or indirectly refers to obj in class c, return rc
    def get_class_usage_of(self, c: Union[str, ClassDefinition], obj):
        c = self.classdef(c)
        slots = self.class_slotdefs(c, True, True)
        for s in slots:
            s = self.slotdef(s, c)
            r = self.class_slot_range(c, s)
            if r and self.classdef(r):
                r = self.classdef(r)
                if r.name == obj.name:
                    return r
                for a in self.ancestors(r, use_mixins=True, reflexive=False):
                    if a.name == obj.name:
                        return r
        return None

    # this is more expensive than using sets, but preserves order;
    # may be worth using an explicit orderedDicts lib, see https://stackoverflow.com/questions/1653970/does-python-have-an-ordered-set
    def remove_dupe_objs(self, objs):
        r = []
        visited = {}
        for obj in objs:
            if obj.name not in visited:
                visited[obj.name] = True
                r.append(obj)
        return r
    
    def ancestors(self, obj, use_mixins=False, reflexive=True, is_slot=False, use_isa=True, visited=[]):
        if isinstance(obj,str):
            if is_slot:
                objx = self.slotdef(obj)
            else:
                objx = self.classdef(obj)
            assert objx is not None, "no class/slot def for '{}'".format(obj)
            obj = objx

        if obj.name in visited:
            raise ValueError("CYCLE: {} + {}".format(obj.name, visited))

        v2 = list(visited) + [obj.name]
        ancs = []
        if reflexive:
            ancs.append(obj)
        if obj.is_a and use_isa:
            ancs += self.ancestors(obj.is_a, use_mixins=use_mixins, reflexive=True, is_slot=is_slot, visited=v2)
        if obj.mixins and use_mixins:
            for m in obj.mixins:
                ancs += self.ancestors(m, use_mixins=use_mixins, reflexive=True, is_slot=is_slot, visited=v2)
        #return list(set(ancs))
        return self.remove_dupe_objs(ancs)
    
    def class_slotdefs(self, c: str, use_isa=True, use_mixins=False):
        """
        get all slots applicable for a class
        """
        # ensure an object
        cls = self.classdef(c)
        slots = []
        for a in self.ancestors(c, use_mixins=use_mixins, use_isa=use_isa):
            if a.slots is not None:
                for s in a.slots:
                    slots.append(s)
        return slots

    def class_slotdef_inherited_from(self, c, s):
        """
        Return the class from which a slotdef in a class is inherited from
        """
        # ensure an object
        cls = self.classdef(c)
        for a in self.ancestors(c, use_mixins=True, use_isa=True):
            if a.slots is not None:
                for s1 in a.slots:
                    if s.name == s1:
                        return a
        return None
    
    def class_slot_range(self, c, s):
        """
        Find the range of a slot when that slot is used in the context of a given class.

        Arguments can be either names or instances of SlotDefinition/ClassDefinition classes
        """
        return self.class_slot_getattr(c, s, 'range', defaultval=None)
    
    def class_slot_multivalued(self, c, s):
        """
        Find if a slot is multivalued
        """
        return self.class_slot_getattr(c, s, 'multivalued', defaultval=False)

    # TODO: there may be multiple paths to get to a class
    # use the non-redundant result
    def class_slot_getattr(self, c, s, attr, defaultval=None):
        """
        Lookup an object attribute of a slot using inheritance
        """
        c = self.classdef(c)
        s = self.slotdef(s, c)

        # class-specific slot_usage takes priority
        if c is not None and c.slot_usage is not None:
            for su in c.slot_usage:
                try:
                    if su.name == s.name and su.__getattribute__(attr) is not None:
                        return su.__getattribute__(attr)
                except AttributeError:
                    pass


        # inheritance up class mixins
        if c.mixins:
            for m in c.mixins:
                v = self.class_slot_getattr(m, s, attr, defaultval=defaultval)
                if v is not None:
                    return v

        # general multivalued for slot
        try:
            if s.__getattribute__(attr):
                return s.__getattribute__(attr)
        except AttributeError:
            pass
                
        # inheritance up slot mixins
        if s.mixins:
            for m in s.mixins:
                v = self.class_slot_getattr(c, m, attr, defaultval=defaultval)
                if v is not None:
                    return v
                
        # inheritance up class hierarchy
        if c.is_a:
            v = self.class_slot_getattr(c.is_a, s, attr, defaultval=defaultval)
            if v is not None:
                return v
        
        # inheritance up slot hierarchy
        if s.is_a:
            v = self.class_slot_getattr(c, s.is_a, attr, defaultval=defaultval)
            if v is not None:
                return v
        
        return defaultval
    
