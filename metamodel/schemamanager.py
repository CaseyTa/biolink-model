"""
Datamodel for metamodel

See datamodel.py for pure (autogenerated) data access objects

This module provides an OO facade for accessing these
"""
import logging
from enum import Enum
from io import StringIO
from typing import Union, TextIO, cast, List, Dict
from urllib.request import Request, urlopen

import yaml

from metamodel.metamodel import SchemaDefinition, Definition
from metamodel.schemaloader import load_schema


class NameStyle(Enum):
    """
    Different systems have different name conventions.

    E.g. in most programming languages classes are CamelCase

    in some, property names are underscore separated.
    """
    CAMELCASE = 1
    UNDERSCORE = 2   ## aka snake-case
    NATURAL = 3
    LCAMELCASE = 4


class SchemaManager:
    """
    Facade object for working with schemas
    """
    def __init__(self) -> None:
        """
        """
        self.schema: SchemaDefinition = SchemaDefinition()
        self.loaded: List[str] = None
        self.unreferenced = set()

    def load_schema(self, data: Union[str, TextIO], depth=0):
        """   Load a schema and apply metamodel semantics

        @param data: URI, file name or string yaml schema
        @param depth:
        @return:
        """
        schemas = load_schema(data)
        for sname, sdef in {k: SchemaDefinition(name=k, **v) for k, v in schemas.items()}.items():
            logging.info("LOADING SCHEMA {sname}")
            self.merge_schema(sdef)
            self.loaded.append(sname)
        for sname in self.schema.imports:
            if sname not in self.loaded:
                self.load_schema(sname)
        # Error checking

        # Inject slots into classes
        for slot in self.schema.slots.values():
            if slot.domain and slot not in self.schema.classes[slot.domain].slots:
                self.schema.classes[slot.domain].slots.add(slot)

        # Apply slot extensions to classes
        #


        # TODO: Error checking
        #
        # if len(errs) > 0:
        #     logging.error("CONFIG ERRS: {}".format(errs))

        logging.info('LOADING IMPORTS FOR {}'.format(schema.name))
        self.load_imports(schema, depth)
        if depth == 0:
            self.schema = schema
            logging.info('APPLYING EXTENSIONS')
            self.apply_extensions(schema)
        return schema


    def merge_schema(self, mergee: SchemaDefinition) -> None:
        assert self.schema.name is not None, "Schema name must be supplied"
        if self.schema.id is None:
            self.schema.id = mergee.id
        if self.schema.license is None:
            self.schema.license = mergee.license

        self.schema.imports += mergee.imports
        self.schema.classes += mergee.classes
        self.schema.slots += mergee.slots
        self.schema.types += mergee.types


    def _merge_dicts(self, s1name: str, s2name: str, d1: Dict[str, Definition], d2: Dict[str, Definition]) -> None:
        for k, v in d2.items():
            if k in d1:
                raise ValueError("Conflicting definitions for {k} in schema {s1name} and {s2name}")
            d1[k] = v

                     
    def apply_extensions(self, schema):
        """
        Auto-apply 'reverse-isas'
        """
        for c in schema.classes:
            c = self.classdef(c)
            if c.apply_to:
                tc = self.classdef(c.apply_to)
                if tc:
                    if tc.mixins is None:
                        tc.mixins = []
                    logging.info("Applying '{}' to '{}'".format(c.name, tc.name))
                    tc.mixins.append(c.name)
        

    def get_name(self, n, style):
        if style == NameStyle.UNDERSCORE:
            return n.replace(" ","_").replace(",","")
        if style == NameStyle.CAMELCASE:
            # TODO: fix so microRNA -> MicroRNA
            return n.title().replace(" ","").replace(",","")
        if style == NameStyle.LCAMELCASE:
            s = n.title().replace(" ","").replace(",","")
            return s[0].lower() + s[1:]
        return n

    def predicates(self):
        if not self.schema.slots:
            return []
        return [self.slotdef(s) for s in self.schema.slots]
    
    def root_predicates(self):
        """
        All slots/properties that lack a parent
        """
        return [p for p in self.predicates() if not p.is_a]
        
    def slotdef(self, sn: Union[str, SlotDefinition], c: Optional[ClassDefinition]=None) -> SlotDefinition:
        """
        lookup a slot in the schema by name

        Returns
        -------
        SlotDefinition
        """
        assert sn is not None
        if isinstance(sn, SlotDefinition):
            return sn
        for s in self.schema.slots:
            if s.name == sn:
                return s

        # if not found, can use local definition
        if c is not None and c.slot_usage is not None:
            for s in c.slot_usage:
                if s.name == sn:
                    return s
        if sn not in self.unreferenced:
            logging.warning("No such slot: {} from class {}".format(sn, c))
            self.unreferenced.add(sn)

    def slot_name(self, s, style=NameStyle.UNDERSCORE):
        """
        Get the name of a slot using appropriate style

        Arguments
        ---------
        - s : SlotDefinition or string
        - style: NameStyle

        Returns
        -------
        string
        """
        # ensure an object
        assert s is not None
        slot = self.slotdef(s)
        return self.get_name(slot.name, style)

    def classdef(self, cn):
        """
        lookup a class in the schema by name

        Returns
        -------
        ClassDefinition
        """
        if isinstance(cn,ClassDefinition):
            return cn
        for c in self.schema.classes:
            if c.name == cn:
                return c
        if cn not in self.unreferenced:
            logging.warning("No such class: {}".format(cn))
            self.unreferenced.add(cn)

    def typedef(self, tn):
        """
        lookup a type in the schema by name

        Returns
        -------
        TypeDefinition
        """
        if isinstance(tn,TypeDefinition):
            return tn
        for t in self.schema.types:
            if t.name == tn:
                return t
        if tn not in self.unreferenced:
            logging.warning("No such type: {}".format(tn))
            self.unreferenced.add(tn)


    def class_name(self, c, style=NameStyle.CAMELCASE):
        """
        Get the name of a class using appropriate style

        Arguments
        ---------
        - s : ClassDefinition or string
        - style: NameStyle

        Returns
        -------
        string
        """
        # ensure an object
        cls = self.classdef(c)
        if cls is None:
            raise ValueError("No cls for {}".format(c))
        if cls.name is None:
            logging.error("No class name for {}".format(c))
        return self.get_name(cls.name, style)

    def obj_name(self, obj):
        if isinstance(obj, ClassDefinition):
            return self.class_name(obj)
        else:
            return self.slot_name(obj)
    
    def obj_uri(self, obj):
        return "http://bioentity.io/vocab/{}".format(self.obj_name(obj))
    
    
    def child_nodes(self, obj, mixin=True):
        nodes = [c for c in self.schema.classes
                 if c.is_a is not None and c.is_a==obj.name]
        nodes += [c for c in self.schema.slots
                  if c.is_a is not None and c.is_a==obj.name]
        if not mixin:
            nodes = [c for c in nodes if not c.mixin]
        return nodes

    def child_nodes_by_mixin(self, obj):
        nodes = [c for c in self.schema.classes
                 if c.mixins is not None and obj.name in c.mixins]
        return nodes

    # returns pairs (cls, refCls) if cls references obj via refCls
    def all_class_usages(self, obj):
        pairs = []
        for c in self.schema.classes:
            rc =  self.get_class_usage_of(c, obj)
            if rc is not None:
                pairs.append((c, rc))
        return pairs

    # if a reference class rc directly or indirectly refers to obj in class c, return rc
    def get_class_usage_of(self, c, obj):
        c = self.classdef(c)
        slots = self.class_slotdefs(c, True, True)
        for s in slots:
            s = self.slotdef(s, c)
            r = self.class_slot_range(c, s)
            if r and self.classdef(r):
                r = self.classdef(r)
                if r.name == obj.name:
                    return r
                for a in self.ancestors(r, use_mixins=True, reflexive=False):
                    if a.name == obj.name:
                        return r
        return None

    # this is more expensive than using sets, but preserves order;
    # may be worth using an explicit orderedDicts lib, see https://stackoverflow.com/questions/1653970/does-python-have-an-ordered-set
    def remove_dupe_objs(self, objs):
        r = []
        visited = {}
        for obj in objs:
            if obj.name not in visited:
                visited[obj.name] = True
                r.append(obj)
        return r
    
    def ancestors(self, obj, use_mixins=False, reflexive=True, is_slot=False, use_isa=True, visited=[]):
        if isinstance(obj,str):
            if is_slot:
                objx = self.slotdef(obj)
            else:
                objx = self.classdef(obj)
            assert objx is not None, "no class/slot def for '{}'".format(obj)
            obj = objx

        if obj.name in visited:
            raise ValueError("CYCLE: {} + {}".format(obj.name, visited))

        v2 = list(visited) + [obj.name]
        ancs = []
        if reflexive:
            ancs.append(obj)
        if obj.is_a and use_isa:
            ancs += self.ancestors(obj.is_a, use_mixins=use_mixins, reflexive=True, is_slot=is_slot, visited=v2)
        if obj.mixins and use_mixins:
            for m in obj.mixins:
                ancs += self.ancestors(m, use_mixins=use_mixins, reflexive=True, is_slot=is_slot, visited=v2)
        #return list(set(ancs))
        return self.remove_dupe_objs(ancs)
    
    def class_slotdefs(self, c: str, use_isa=True, use_mixins=False):
        """
        get all slots applicable for a class
        """
        # ensure an object
        cls = self.classdef(c)
        slots = []
        for a in self.ancestors(c, use_mixins=use_mixins, use_isa=use_isa):
            if a.slots is not None:
                for s in a.slots:
                    slots.append(s)
        return slots

    def class_slotdef_inherited_from(self, c, s):
        """
        Return the class from which a slotdef in a class is inherited from
        """
        # ensure an object
        cls = self.classdef(c)
        for a in self.ancestors(c, use_mixins=True, use_isa=True):
            if a.slots is not None:
                for s1 in a.slots:
                    if s.name == s1:
                        return a
        return None
    
    def class_slot_range(self, c, s):
        """
        Find the range of a slot when that slot is used in the context of a given class.

        Arguments can be either names or instances of SlotDefinition/ClassDefinition classes
        """
        return self.class_slot_getattr(c, s, 'range', defaultval=None)
    
    def class_slot_multivalued(self, c, s):
        """
        Find if a slot is multivalued
        """
        return self.class_slot_getattr(c, s, 'multivalued', defaultval=False)

    # TODO: there may be multiple paths to get to a class
    # use the non-redundant result
    def class_slot_getattr(self, c, s, attr, defaultval=None):
        """
        Lookup an object attribute of a slot using inheritance
        """
        c = self.classdef(c)
        s = self.slotdef(s, c)

        # class-specific slot_usage takes priority
        if c is not None and c.slot_usage is not None:
            for su in c.slot_usage:
                try:
                    if su.name == s.name and su.__getattribute__(attr) is not None:
                        return su.__getattribute__(attr)
                except AttributeError:
                    pass


        # inheritance up class mixins
        if c.mixins:
            for m in c.mixins:
                v = self.class_slot_getattr(m, s, attr, defaultval=defaultval)
                if v is not None:
                    return v

        # general multivalued for slot
        try:
            if s.__getattribute__(attr):
                return s.__getattribute__(attr)
        except AttributeError:
            pass
                
        # inheritance up slot mixins
        if s.mixins:
            for m in s.mixins:
                v = self.class_slot_getattr(c, m, attr, defaultval=defaultval)
                if v is not None:
                    return v
                
        # inheritance up class hierarchy
        if c.is_a:
            v = self.class_slot_getattr(c.is_a, s, attr, defaultval=defaultval)
            if v is not None:
                return v
        
        # inheritance up slot hierarchy
        if s.is_a:
            v = self.class_slot_getattr(c, s.is_a, attr, defaultval=defaultval)
            if v is not None:
                return v
        
        return defaultval
    
