"""
Datamodel for metamodel

See datamodel.py for pure (autogenerated) data access objects

This module provides an OO facade for accessing these
"""

import logging
from .metamodel imports *

class NameStyle(Enum):
    """
    Different systems have different name conventions.

    E.g. in most programming languages classes are CamelCase

    in some, property names are underscore separated.
    """
    CAMELCASE = 1
    UNDERSCORE = 2
    NATURAL = 3

class Manager(object):
    """
    Facade object for working with schemas
    """
    def __init__(self, schema):
        """
        initialize

        Arguments
        ---------
        - schema : SchemaDefinition
        """
        self.schema = schema

    def get_name(self, n, style):
        if style == NameStyle.UNDERSCORE:
            return n.replace(" ","_")
        if style == NameStyle.CAMELCASE:
            return n.title().replace(" ","")
        return n

        
    def slotdef(self, sn):
        """
        lookup a slot in the schema by name

        Returns
        -------
        SlotDefinition
        """
        if isinstance(sn,SlotDefinition):
            return sn
        for s in schema.slots:
            if s.name == sn:
                return s
        logging.warning("No such slot: {}".format(sn))

    def slot_name(self, s, style=NameStyle.UNDERSCORE):
        """
        Get the name of a slot using appropriate style

        Arguments
        ---------
        - s : SlotDefinition or string
        - style: NameStyle

        Returns
        -------
        string
        """
        # ensure an object
        slot = self.slotdef(s)
        return self.get_name(slot.name, style)

    def classdef(self, cn):
        """
        lookup a class in the schema by name

        Returns
        -------
        ClassDefinition
        """
        if isinstance(cn,ClassDefinition):
            return cn
        for c in schema.classes:
            if c.name == cn:
                return c
        logging.warning("No such class: {}".format(cn))


    def class_name(self, c, style=NameStyle.CAMELCASE):
        """
        Get the name of a class using appropriate style

        Arguments
        ---------
        - s : ClassDefinition or string
        - style: NameStyle

        Returns
        -------
        string
        """
        # ensure an object
        cls = self.classdef(c)
        return self.get_name(cls.name, style)

    def ancestors(self, obj, use_mixins=False, reflexive=True, is_slot=False, use_isa=True):
        if instanceof(obj,str):
            if is_slot:
                obj = self.slotdef(obj)
            else:
                obj = self.classdef(obj)
        ancs = []
        if reflexive:
            ancs.append(obj)
        if obj.is_a and use_isa:
            ancs += self.ancestors(obj.is_a, use_mixins=use_mixins, reflexive=True, is_slot=is_slot)
        if obj.mixins and use_mixins:
            for m in obj.mixins:
                ancs += self.ancestors(m, use_mixins=use_mixins, reflexive=True, is_slot=is_slot)
        return list(set(ancs))
    
    def class_slotdefs(self, c, use_isa=True, use_mixins=False):
        """
        get all slots applicable for a class
        """
        # ensure an object
        cls = self.classdef(c)
        slots = set()
        for a in self.ancestors(c, use_mixins=use_mixins, use_isa=use_isa):
            if a.slots:
                slots.update(a.slots)
        return list(a.slots)
    
    def class_slot_range(self, c, s):
        """
        Find the range of a slot when that slot is used in the context of a given class.

        Arguments can be either names or instances of SlotDefinition/ClassDefinition classes
        """
        classdef = self.classdef(c)
        s = self.slotdef(s)

        # class-specific usage takes priority
        if classdef is not None and classdef.slot_usage is not None:
            for su in classdef.slot_usage:
                if su.name == s.name and su.range:
                    return su.range

        # general range for slot
        if s.range:
            return s.range

        if c.mixins:
            for m in c.mixins:
                r = self.class_slot_range(c, s)
                if r is not None:
                    return r
        if c.is_a:
            r = self.is_a
            if r is not None:
                return r
        
        return r
