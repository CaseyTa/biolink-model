"""
Datamodel for metamodel

See datamodel.py for pure (autogenerated) data access objects

This module provides an OO facade for accessing these
"""

from enum import Enum
import logging
from .metamodel import *

class NameStyle(Enum):
    """
    Different systems have different name conventions.

    E.g. in most programming languages classes are CamelCase

    in some, property names are underscore separated.
    """
    CAMELCASE = 1
    UNDERSCORE = 2
    NATURAL = 3

class Manager(object):
    """
    Facade object for working with schemas
    """
    def __init__(self, schema):
        """
        initialize

        Arguments
        ---------
        - schema : SchemaDefinition
        """
        self.schema = schema

    def get_name(self, n, style):
        if style == NameStyle.UNDERSCORE:
            return n.replace(" ","_")
        if style == NameStyle.CAMELCASE:
            return n.title().replace(" ","")
        return n

        
    def slotdef(self, sn):
        """
        lookup a slot in the schema by name

        Returns
        -------
        SlotDefinition
        """
        assert( sn is not None )
        if isinstance(sn,SlotDefinition):
            return sn
        for s in self.schema.slots:
            if s.name == sn:
                return s
        logging.warning("No such slot: {}".format(sn))

    def slot_name(self, s, style=NameStyle.UNDERSCORE):
        """
        Get the name of a slot using appropriate style

        Arguments
        ---------
        - s : SlotDefinition or string
        - style: NameStyle

        Returns
        -------
        string
        """
        # ensure an object
        slot = self.slotdef(s)
        return self.get_name(slot.name, style)

    def classdef(self, cn):
        """
        lookup a class in the schema by name

        Returns
        -------
        ClassDefinition
        """
        if isinstance(cn,ClassDefinition):
            return cn
        for c in self.schema.classes:
            if c.name == cn:
                return c
        logging.warning("No such class: {}".format(cn))


    def class_name(self, c, style=NameStyle.CAMELCASE):
        """
        Get the name of a class using appropriate style

        Arguments
        ---------
        - s : ClassDefinition or string
        - style: NameStyle

        Returns
        -------
        string
        """
        # ensure an object
        cls = self.classdef(c)
        if cls is None:
            raise ValueError("No cls for {}".format(c))
        return self.get_name(cls.name, style)

    def ancestors(self, obj, use_mixins=False, reflexive=True, is_slot=False, use_isa=True, visited=[]):
        if isinstance(obj,str):
            if is_slot:
                obj = self.slotdef(obj)
            else:
                obj = self.classdef(obj)

        if obj.name in visited:
            raise ValueError("CYCLE: {} + {}".format(obj.name, visited))

        v2 = list(visited) + [obj.name]
        ancs = []
        if reflexive:
            ancs.append(obj)
        if obj.is_a and use_isa:
            ancs += self.ancestors(obj.is_a, use_mixins=use_mixins, reflexive=True, is_slot=is_slot, visited=v2)
        if obj.mixins and use_mixins:
            for m in obj.mixins:
                ancs += self.ancestors(m, use_mixins=use_mixins, reflexive=True, is_slot=is_slot, visited=v2)
        return list(set(ancs))
    
    def class_slotdefs(self, c, use_isa=True, use_mixins=False):
        """
        get all slots applicable for a class
        """
        # ensure an object
        cls = self.classdef(c)
        slots = set()
        for a in self.ancestors(c, use_mixins=use_mixins, use_isa=use_isa):
            if a.slots is not None:
                slots.update(a.slots)
        return list(slots)
    
    def class_slot_range(self, c, s):
        """
        Find the range of a slot when that slot is used in the context of a given class.

        Arguments can be either names or instances of SlotDefinition/ClassDefinition classes
        """
        return self.class_slot_getattr(c, s, 'range', defaultval=None)
    
    def class_slot_multivalued(self, c, s):
        """
        Find if a slot is multivalued
        """
        return self.class_slot_getattr(c, s, 'multivalued', defaultval=False)

    def class_slot_getattr(self, c, s, attr, defaultval=None):
        """
        Lookup an object attribute of a slot using inheritance
        """
        c = self.classdef(c)
        s = self.slotdef(s)

        # class-specific usage takes priority
        if c is not None and c.slot_usage is not None:
            for su in c.slot_usage:
                if su.name == s.name and su.__getattribute__(attr) is not None:
                    return su.__getattribute__(attr)

        # general multivalued for slot
        if s.__getattribute__(attr):
            return s.__getattribute__(attr)

        # inheritance up class hierarchy
        if c.is_a:
            v = self.class_slot_getattr(c.is_a, s, attr, defaultval=defaultval)
            if v is not None:
                return v
        
        # inheritance up slot hierarchy
        if s.is_a:
            v = self.class_slot_getattr(c, s.is_a, attr, defaultval=defaultval)
            if v is not None:
                return v
            
        # inheritance up class mixins
        if c.mixins:
            for m in c.mixins:
                v = self.class_slot_getattr(m, s, attr, defaultval=defaultval)
                if v is not None:
                    return v
        
        # inheritance up slot mixins
        if s.mixins:
            for m in s.mixins:
                v = self.class_slot_getattr(c, m, attr, defaultval=defaultval)
                if v is not None:
                    return v
        
        return False
    
